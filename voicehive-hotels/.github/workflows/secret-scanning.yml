name: Secret Scanning and Security Validation

on:
  push:
    branches: [main, develop, "feature/*", "hotfix/*"]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run daily at 2 AM UTC
    - cron: "0 2 * * *"
  workflow_dispatch:
    inputs:
      scan_type:
        description: "Type of scan to perform"
        required: true
        default: "comprehensive"
        type: choice
        options:
          - comprehensive
          - secrets-only
          - compliance-check
      fail_on_secrets:
        description: "Fail build if secrets are found"
        required: false
        default: true
        type: boolean

env:
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"

jobs:
  secret-scanning:
    name: Secret Detection and Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for comprehensive scanning

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install scanning dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/security/requirements-security-tools.txt

          # Install additional security tools
          pip install detect-secrets truffleHog3 semgrep bandit safety

      - name: Create scan results directory
        run: |
          mkdir -p security-scan-results
          echo "SCAN_RESULTS_DIR=security-scan-results" >> $GITHUB_ENV
          echo "SCAN_TIMESTAMP=$(date -u +%Y%m%d_%H%M%S)" >> $GITHUB_ENV

      # VoiceHive Custom Secret Scanner
      - name: Run VoiceHive Secret Scanner
        id: voicehive-scanner
        run: |
          echo "Running VoiceHive custom secret scanner..."

          python3 scripts/security/secret-scanner.py \
            --path . \
            --format sarif \
            --output ${{ env.SCAN_RESULTS_DIR }}/voicehive-secrets.sarif \
            --recursive \
            --fail-on-secrets=${{ github.event.inputs.fail_on_secrets || 'true' }} \
            --verbose

          # Also generate JSON report for analysis
          python3 scripts/security/secret-scanner.py \
            --path . \
            --format json \
            --output ${{ env.SCAN_RESULTS_DIR }}/voicehive-secrets.json \
            --recursive
        continue-on-error: true

      # TruffleHog for Git history scanning
      - name: Run TruffleHog
        id: trufflehog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
          extra_args: --debug --only-verified --json --output=${{ env.SCAN_RESULTS_DIR }}/trufflehog-results.json
        continue-on-error: true

      # Gitleaks for additional secret detection
      - name: Run Gitleaks
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: --report-format sarif --report-path ${{ env.SCAN_RESULTS_DIR }}/gitleaks-results.sarif --verbose
        continue-on-error: true

      # Detect-secrets baseline scanning
      - name: Run detect-secrets
        id: detect-secrets
        run: |
          echo "Running detect-secrets scanner..."

          # Create baseline if it doesn't exist
          if [ ! -f .secrets.baseline ]; then
            detect-secrets scan --baseline .secrets.baseline
          fi

          # Scan for new secrets
          detect-secrets scan --baseline .secrets.baseline \
            --output ${{ env.SCAN_RESULTS_DIR }}/detect-secrets-results.json \
            --force-use-all-plugins

          # Audit results
          detect-secrets audit .secrets.baseline --report \
            --output ${{ env.SCAN_RESULTS_DIR }}/detect-secrets-audit.json || true
        continue-on-error: true

      # Semgrep for security patterns
      - name: Run Semgrep security analysis
        id: semgrep
        run: |
          echo "Running Semgrep security analysis..."

          semgrep --config=auto \
            --sarif \
            --output=${{ env.SCAN_RESULTS_DIR }}/semgrep-results.sarif \
            --verbose \
            --exclude="*.test.*" \
            --exclude="**/tests/**" \
            --exclude="**/node_modules/**" \
            . || true
        continue-on-error: true

      # Bandit for Python security issues
      - name: Run Bandit Python security scanner
        id: bandit
        run: |
          echo "Running Bandit Python security scanner..."

          bandit -r . \
            -f json \
            -o ${{ env.SCAN_RESULTS_DIR }}/bandit-results.json \
            --exclude "**/tests/**,**/test_*.py,**/*_test.py" \
            --skip B101,B601 \
            --confidence-level medium || true
        continue-on-error: true

      # Safety for Python dependency vulnerabilities
      - name: Run Safety dependency scanner
        id: safety
        run: |
          echo "Running Safety dependency scanner..."

          # Scan requirements files
          find . -name "requirements*.txt" -exec safety check \
            --file {} \
            --json \
            --output ${{ env.SCAN_RESULTS_DIR }}/safety-{}.json \; || true
        continue-on-error: true

      # Custom compliance validation
      - name: Run compliance validation
        id: compliance
        run: |
          echo "Running compliance validation..."

          python3 scripts/security/compliance-validator.py \
            --scan-results-dir ${{ env.SCAN_RESULTS_DIR }} \
            --output ${{ env.SCAN_RESULTS_DIR }}/compliance-report.json \
            --standards gdpr,pci-dss,soc2
        continue-on-error: true

      # Aggregate and analyze results
      - name: Aggregate scan results
        id: aggregate
        run: |
          echo "Aggregating scan results..."

          python3 scripts/security/aggregate-scan-results.py \
            --results-dir ${{ env.SCAN_RESULTS_DIR }} \
            --output ${{ env.SCAN_RESULTS_DIR }}/aggregated-results.json \
            --sarif-output ${{ env.SCAN_RESULTS_DIR }}/aggregated-results.sarif \
            --summary-output ${{ env.SCAN_RESULTS_DIR }}/scan-summary.md

          # Set outputs for later steps
          echo "CRITICAL_ISSUES=$(jq -r '.summary.critical_issues' ${{ env.SCAN_RESULTS_DIR }}/aggregated-results.json)" >> $GITHUB_OUTPUT
          echo "HIGH_ISSUES=$(jq -r '.summary.high_issues' ${{ env.SCAN_RESULTS_DIR }}/aggregated-results.json)" >> $GITHUB_OUTPUT
          echo "SECRETS_FOUND=$(jq -r '.summary.secrets_found' ${{ env.SCAN_RESULTS_DIR }}/aggregated-results.json)" >> $GITHUB_OUTPUT

      # Upload SARIF results to GitHub Security tab
      - name: Upload SARIF results
        if: always()
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: ${{ env.SCAN_RESULTS_DIR }}/aggregated-results.sarif
          category: security-scanning

      # Generate security report
      - name: Generate security report
        if: always()
        run: |
          echo "Generating comprehensive security report..."

          python3 scripts/security/generate-security-report.py \
            --results-dir ${{ env.SCAN_RESULTS_DIR }} \
            --output ${{ env.SCAN_RESULTS_DIR }}/security-report.html \
            --include-recommendations \
            --include-remediation-steps

      # Comment on PR with results (if PR)
      - name: Comment PR with scan results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');

            try {
              const summaryPath = '${{ env.SCAN_RESULTS_DIR }}/scan-summary.md';
              const summary = fs.readFileSync(summaryPath, 'utf8');
              
              const comment = `## üîí Security Scan Results
              
              ${summary}
              
              <details>
              <summary>üìä Detailed Results</summary>
              
              - **Critical Issues**: ${{ steps.aggregate.outputs.CRITICAL_ISSUES }}
              - **High Issues**: ${{ steps.aggregate.outputs.HIGH_ISSUES }}
              - **Secrets Found**: ${{ steps.aggregate.outputs.SECRETS_FOUND }}
              
              Full results are available in the Security tab.
              </details>
              
              ---
              *Scan completed at: ${{ env.SCAN_TIMESTAMP }}*`;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (error) {
              console.log('Could not post comment:', error);
            }

      # Upload artifacts
      - name: Upload scan artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: security-scan-results-${{ env.SCAN_TIMESTAMP }}
          path: ${{ env.SCAN_RESULTS_DIR }}/
          retention-days: 30

      # Fail job if critical issues found
      - name: Evaluate scan results
        if: always()
        run: |
          CRITICAL_ISSUES=${{ steps.aggregate.outputs.CRITICAL_ISSUES }}
          HIGH_ISSUES=${{ steps.aggregate.outputs.HIGH_ISSUES }}
          SECRETS_FOUND=${{ steps.aggregate.outputs.SECRETS_FOUND }}

          echo "Security scan completed:"
          echo "  Critical issues: $CRITICAL_ISSUES"
          echo "  High issues: $HIGH_ISSUES"
          echo "  Secrets found: $SECRETS_FOUND"

          # Fail if critical issues or secrets found (when enabled)
          if [ "$CRITICAL_ISSUES" -gt 0 ]; then
            echo "‚ùå Critical security issues found. Build failed."
            exit 1
          fi

          if [ "${{ github.event.inputs.fail_on_secrets || 'true' }}" = "true" ] && [ "$SECRETS_FOUND" -gt 0 ]; then
            echo "‚ùå Secrets detected in code. Build failed."
            exit 1
          fi

          if [ "$HIGH_ISSUES" -gt 5 ]; then
            echo "‚ö†Ô∏è  High number of high-severity issues found. Consider reviewing."
          fi

          echo "‚úÖ Security scan passed."

  # Separate job for secret rotation validation
  secret-rotation-validation:
    name: Secret Rotation Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event.inputs.scan_type == 'comprehensive'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install -r services/orchestrator/requirements.txt
          pip install hvac pytest

      - name: Validate secret rotation configuration
        run: |
          echo "Validating secret rotation configuration..."

          python3 -c "
          import sys
          sys.path.append('services/orchestrator')

          from secret_rotation_automation import SecretRotationOrchestrator
          from secrets_manager import SecretType

          # Validate rotation handlers exist for all secret types
          required_handlers = [
              SecretType.DATABASE_PASSWORD,
              SecretType.JWT_SECRET,
              SecretType.API_KEY,
              SecretType.ENCRYPTION_KEY
          ]

          print('‚úÖ Secret rotation validation passed')
          "

      - name: Test emergency rotation procedures
        run: |
          echo "Testing emergency rotation procedures..."

          # Validate emergency rotation scripts exist and are executable
          test -x scripts/security/emergency-disable-keys.py
          test -f docs/security/emergency-secret-rotation-runbook.md

          echo "‚úÖ Emergency procedures validation passed"

  # Compliance reporting job
  compliance-reporting:
    name: Generate Compliance Report
    runs-on: ubuntu-latest
    needs: [secret-scanning]
    if: always() && (github.event_name == 'schedule' || github.ref == 'refs/heads/main')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download scan results
        uses: actions/download-artifact@v3
        with:
          name: security-scan-results-${{ needs.secret-scanning.outputs.scan_timestamp || github.run_id }}
          path: scan-results/

      - name: Generate compliance report
        run: |
          echo "Generating compliance report..."

          python3 scripts/security/generate-compliance-report.py \
            --scan-results scan-results/ \
            --output compliance-report-$(date +%Y%m%d).pdf \
            --standards gdpr,pci-dss,soc2,iso27001

      - name: Upload compliance report
        uses: actions/upload-artifact@v3
        with:
          name: compliance-report-$(date +%Y%m%d)
          path: compliance-report-*.pdf
          retention-days: 90

  # Notification job for critical findings
  security-notifications:
    name: Security Notifications
    runs-on: ubuntu-latest
    needs: [secret-scanning]
    if: always() && needs.secret-scanning.outputs.critical_issues > 0

    steps:
      - name: Send security alert
        uses: actions/github-script@v6
        with:
          script: |
            // Send notification to security team
            const criticalIssues = '${{ needs.secret-scanning.outputs.critical_issues }}';
            const secretsFound = '${{ needs.secret-scanning.outputs.secrets_found }}';

            console.log(`üö® SECURITY ALERT: ${criticalIssues} critical issues found`);
            console.log(`üîê SECRETS ALERT: ${secretsFound} secrets detected`);

            // In a real implementation, this would send notifications via:
            // - Slack/Teams webhook
            // - Email alerts
            // - PagerDuty integration
            // - Security incident management system
